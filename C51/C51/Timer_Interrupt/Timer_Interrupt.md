# 单片机第8课——定时器中断
#### <p align="right"> 作者：米米糊</p>
#### <p align="right"> 归档人：HITLYT</p>
## 上集回顾~~
### 数码管
如何偷懒（封装一个数码管驱动）
### 再探C语言
C语言子函数
## 本集预览~~
### 中断
+ 什么是中断
+ 中断的好处
+ 复习外部中断
### 定时器中断
+ 定时器中断的使用
+ +1s的时钟
## 时钟
这次我们来说说时钟。

晶振为我们的单片机提供了一个固定的时钟信号。时钟信号在单片机内部就是一个个的方波信号。

图片1

所谓分频，就是让时钟的频率减慢。

图片2

假设单片机输入的时钟是24MHz、
+ 请问，12分频后的频率是多少？

<p align="right"> 答案：2MHz</p>

+ 那么，分频后对应的周期是多少？

图片3

## 延时
回忆一下之前的延时
+ 采用空循环来浪费时间，效率低
+ 比如，希望让一个灯一秒钟闪烁一次，那么在等待的过程中CPU不能干任何其他事情，只能等待……
+ 我们多么希望能有一个东西，不干扰CPU干别的事情，只是默默地计时，等到时间到了指定时间，就跑过来提醒一下CPU该放下手头的事，让灯闪一下了……
+ 它就是——定时器（计数器）
## 溢出（纠正之前的一个错误~~）
（其实也不能叫纠正……因为在开始的时候有些东西理解起来比较费力，所以只能用错误的方法来表述，才能易于理解，随着学的东西多了，理解能力强了，就可以开始接受正确的解释了~~）
+ 一个unsigned char 类型的变量，最大值是255，那么，如果让他再加1，变量里的内容会变成多少呢？ 
+ 之前告诉大家说：千万不要超过255，否则会变成“乱码”……那么，究竟会变成什么呢？不是乱码！是一个确定的数！
```
unsigned char a;
```
当a=255时，即a=0xff时，其对应的二进制应该是
```
11111111
```
把这个数加1，列一个竖式看看~~

图片4

得到的结果需要用9位（bit）二进制数才能保存，但是a这个变量只有8位的存储空间，所以，丢掉最高位，只要低8位。所以，最后得到的结果是0。
```
unsigned int a;
a=0;
a=a-2;//减完后a的值是？
```

图片5

再来给难点的
```
unsigned char a;
//注意,这次a是有符号的
//提示：8为有符号数的范围是-128~+127
a=127;
a= a + 1；
```

图片6
图片7

做加法之前，a的符号位是0，表明这是一个正数~~

可是，加完之后，由于进位了，a的符号位成了1，竟然变成了负数……

那么这个负数究竟是多少呢？以后会学到，负数是用补码表示的~~用“取反加一”的口诀获得它对应的原码，应该是：
```
1000 000
```
对应的十进制数是128，由于这是一个负数，所以最终答案是-128

以上这些折腾人的东西就叫做

**溢出**

绝对的双刃剑！！

把溢出用好，可以在一定程度上简化程序，并且在硬件中很多功能都是基于溢出来实现的。但是，用不好的话，程序会出大问题，很多软件的安全漏洞（比如windows操作系统的）都是由于溢出引起的……
## 寄存器
### 两只水桶
为了揭开定时器的真面目，先认识两个水桶~~

**TH0和TL0**

TH0和TL0都是8位的寄存器（理解为变量就好），两个8位的定时器共同组成了一个16位的定时器

当TL0计满0xff后，再加1会导致低位溢出，产生的进位将进入到TH0，即TL0每溢出一次，TH0就加 1

图片8

当TH0和TL0都是0xff之后再加1，会导致低位的TL0向高位的TH0溢出，但由于高位也已经满了，故高位会再向前溢出，结果，导致TH0和TL0同时回到0x00

图片9

当TH0溢出或者TL0溢出的时候，便可以让它们通知单片机产生一个中断。那么，究竟是在TH0溢出时产生中断还是在TL0溢出时产生中断呢？这是可以通过编程来设置的~~

如果我们可以让TH0和TL0以固定的速度加1，那么就可以控制TH0和TL0的溢出速率了哦~~换而言之，就是可以控制多长时间让定时器产生一个中断。

还记得刚才讲的分频吗？

TH0和TL0每过12个时钟周期便加1，就是说，定时器的计数频率是晶振频率的十二分频。

之前计算过，24MHz的频率经过12分频是2MHz，对应的周期是0.5μs

如果想定时10ms，应该怎么办？

图片10

我们希望定时器每计数20000次便产生一次溢出

所以，不能从(TH0,TL0)=0x0000开始计时，而要从某一个初值开始计时

+ 一个16位的计时器，可以表示的数字是0~65535
+ 单片机在从65535溢出到0的那一刻引发中断
+ 为定时10ms，我们需要在第20000次加1的时候溢出
```
65535 - 20000 + 1 = 45536
```
+ 45536转换为16进制是0xB1E0（16位）

故它的高八位应该是0xB1,低八位应该是0xE0

即
```
TH0=0xB1;
TL0=0xE0;
```
其实不用算的，我们有小工具

图片11

### TMOD寄存器

图片12

+ M1、M0的不同组合可以让定时器工作在4种不同的状态下，我们只介绍两种，其余两种有兴趣自学~~
+ C/T后面再讨论~~
+ GATE位暂时不予讨论，通常置0，有兴趣自学~
+ 自学方法：芯片数据手册（Datasheet）和百度、Google、BY2HIT论坛……

+ M1=0 M0=1  16位定时器
+ M1=1 M0=0  8位自动重装定时器
+ 由于TMOD寄存器不可位寻址，所以不能在程序中写类似M1=xx;之类的语句，必须对TMOD做整体修改。
### TCON寄存器

图片13

+ TR0和TR1是开启定时器的开关，当TR0=0时，定时器0不计数，TR0=1时定时器才计数。TR1同理。
+ TF1、TF0、IE1、IE0涉及到中断更深入的东西，之后讲解。
+ IT0和IT1~~还记得他们吗？之前使用过，现在知道他们的出处了吧~~
+ TCON是可以位寻址的，故可以直接写类似TR0=1；
## 使能
还记得上节课讲的使能吗？

**第一道门：每个中断各自的门**
+ EX0      外部中断0的使能 
+ ET0      定时器0中断的使能
+ EX1      外部中断1的使能 
+ ET1      定时器1中断的使能 
+ ES        串口中断的使能

**第二道门：所有中断的总控制门**
+ EA    总中断使能

下面继续讨论如何实现一个10ms的定时程序。
+ 为了让定时器0工作在16位模式下，对TMOD进行设置
```
TMOD=0x01;
```
+ 要开启定时器0的中断使能，对ET0进行设置
```
ET0=1;
```
+ 要开启总中断使能，对EA进行设置
```
EA=1;
```
+ 让定时器开始定时，对TR0进行设置
```
TR0=1;
```
完整的开启定时器的程序就应该是这样婶儿的~~
```
TH0=0xB1;//初值的高位
TL0=0xE0;//初值的低位
TMOD=0x01;//16位计时器
EA=1;//开启总中断
ET0=1;//开启定时器中断
TR0=1;//启动定时器
```
貌似很复杂的样子，不过多练练就熟悉了。

另外，传统的51单片机定时器输入时钟是晶振的12分频，但是我们这一单片机款也可以设置成不分频，有兴趣自学~~

现在，让我们通过中断来实现每隔1秒，让不同位数码管亮起的效果。

在这里新添加一个变量t，同时可以删除Delay500ms这个函数，本程序中不使用该函数。

并且删除掉原来while循环中的其他语句，只保留while(1); 

(注意while(1);后面有分号)
```
unsigned int t=0,i=0;
void main() 
{
	timer0_init(); 
	while(1);
}
```
添加初始化定时器的有关代码，并且删除掉原来while循环中的其他语句，只保留while(1);
```
void timer0_init()//定时器0的初始化，函数名随便起
{
	EA=1;//开启总中断
	TH0=0xb1;//初值的高位
	TL0=0xe0;//初值的低位
	TMOD=0x01;//16位计时器
	ET0=1;//开启定时器中断
	TR0=1;//启动定时器
}
```
下面要写中断服务函数啦，定时器0对应的是interrupt1

|中断查询号|中断类型|
|:--:|:--:|
|0|外部中断0|
|1|定时器0|
|2|外部中断1|
|3|定时器1|
|4|串口|










































------The End


----
版权声明：

文章均由哈尔滨工业大学业余无线电俱乐部，技术部原创，转载请联系[BY2HIT技术部 zhaoyuhao@by2hit.net](zhaoyuhao@by2hit.net)